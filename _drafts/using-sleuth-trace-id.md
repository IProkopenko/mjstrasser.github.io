---
layout: post
title: Using the Spring Cloud Sleuth trace ID
categories: tech
tags: spring-boot spring-cloud
---

* TOC
{:toc}

## Introduction

On a recent project we implemented an API service using [Spring
Boot](https://projects.spring.io/spring-boot/) with two operations:

1. initiate a new, asynchronous workflow
2. report on the status of an existing workflow

Each workflow is identified by a unique ID that is generated by the
service on the first call and returned to the consumer. The consumer then uses
that ID in subsequent status requests to identify the workflow.

### Spring Cloud Sleuth

The service is one of a mesh of microservices and we added [Spring Cloud
Sleuth](https://cloud.spring.io/spring-cloud-sleuth/) to provide tracing across microservice calls.
In Sleuth, a **Span** is a basic unit of work, and spans are linked together into a **Trace**
for a single logical transaction.
The [Sleuth Reference](http://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/1.2.1.RELEASE/)
provides much more detail, including this useful diagram:

{% include image.html
   url="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/trace-id.png"
   description="Spring Cloud Sleuth: Span and Trace visualisations" %}

### Generating a unique ID for each workflow

Instead of generating a new ID (e.g. a UUID) we decided to take the
trace ID from Sleuth. Sleuth generates a random long integer as a trace
ID at the beginning of the request and passes that as part of
synchronous requests to other services. 

Part of the rationale for using the trace ID is to reduce log message clutter.
When Sleuth is included, the IDs are inserted into the Spring logs via
the SLF4J MDC. Here is the start of a Spring Boot log message with Sleuth information:

    2017-07-14 13:32:59.094  INFO [api-service,92e9013d25cca084,92e9013d25cca084,false] [10.242.22.52] 25453 --- [nio-8080-exec-1] .n.c.s.d.i.c.InitialDiagnosticController : Received request

* **api-service** is the application name
* **92e9013d25cca084** is both trace ID and the span ID (this happens in the first span of a trace)
* (I canâ€™t remember what **false** means)

## Getting the Sleuth trace ID

Getting the trace ID turned out to be very simple. We created a Spring service
called `Breadcrumb` to return the formatted trace ID.

```java
package com.example.api.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.cloud.sleuth.Tracer;

@Service
public class Breadcrumb {

  @Autowired
  private Tracer tracer;

  public String breadcrumbId() {
    return tracer.getCurrentSpan().traceIdString();
  }
}
```

`Span#traceIdString()` returns the trace ID
in the same hexadecimal format used in the log messages.

The controller that handles the HTTP POST to start the workflow injects
this service and calls `breadcrumb.getBreadcrumb()` to get the current
trace ID string.

## Inserting the Sleuth trace ID

When a consumer requests status of a workflow they provide the breadcrumb ID to use, e.g.:

    GET /v1/workflow/92e9013d25cca084

We want to set that value as the Sleuth trace ID.

### Filter that injects the trace ID

The solution we chose is to create a Spring web filter that addes a Sleuth span as an
attribute of the HTTP request so the Sleuth `TraceFilter` behaves as if the request
is part of an existing Sleuth trace. Our filter needs to:

* be in the filter chain before `TraceFilter`
* read the breadcrumb ID from the request
* construct an appropriate `Span` object
* add the span as an attribute of the request with the correct key

Here is some code, abridged for clarity, with notes below:

```java
@Order(TraceFilter.ORDER - 1)
public class InjectTraceFilter extends GenericFilterBean {

    private static final Pattern REQUEST_PATTERN = Pattern.compile("^/v1/workflow/(?<crumbId>[0-9a-f]+)$");
    private static final String TRACE_REQUEST_ATTR = TraceFilter.class.getName() + ".TRACE";
    private static final String SPAN_NAME_BASE = "http:/v1/workflow/";

    private final Random random = new Random(System.currentTimeMillis());

    @Override
    public void doFilter(final ServletRequest request, final ServletResponse response,
                         final FilterChain chain) throws IOException, ServletException {
        final HttpServletRequest httpRequest = (HttpServletRequest) request;
        final String breadcrumbId = extractBreadcrumbId(httpRequest);
        if (breadcrumbId != null) {
            httpRequest.setAttribute(TRACE_REQUEST_ATTR, spanForId(breadcrumbId));
            chain.doFilter(httpRequest, response);
        } else {
            chain.doFilter(request, response);
        }
    }

    private Span spanForId(final String traceId) {
        return Span.builder()
                .traceId(Span.hexToId(traceId))
                .spanId(random.nextLong())
                .exportable(false)
                .name(SPAN_NAME_BASE + traceId)
                .build();
    }

    private String extractBreadcrumbId(final HttpServletRequest httpRequest) {
        if ("GET".equals(httpRequest.getMethod())) {
            final Matcher matcher = REQUEST_PATTERN.matcher(httpRequest.getRequestURI());
            if (matcher.matches()) {
                return matcher.group("crumbId");
            }
        }
        return null;
    }

}
```

Notes:

* The `extractBreadcrumId` method 
